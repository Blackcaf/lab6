import managers.CollectionManager;
import managers.CommandManager;
import managers.DumpManager;
import managers.FileManager;
import utility.Console;
import utility.Runner;
import utility.StandardConsole;

/**
 * Главный класс приложения
 */
public class Main {
    public static void main(String[] args) {
        try {
            Console console = new StandardConsole();
            FileManager fileManager = new DumpManager();
            CollectionManager collectionManager = new CollectionManager(fileManager);
            CommandManager commandManager = new CommandManager(collectionManager, console);
            Runner runner = new Runner(commandManager, console);
            runner.interactiveMode();
        } catch (Exception e) {
            System.err.println("Ошибка инициализации: " + e.getMessage());
            System.exit(1);
        }
    }
}package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для добавления нового элемента в коллекцию.
 */
public class Add extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public Add(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("add", "добавить новый элемент в коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'add' не принимает аргументы");
        try {
            HumanBeing human = asker.askHumanBeing();
            collectionManager.add(human); // ID генерируется внутри add
            return new ExecutionResponse(true, "Элемент успешно добавлен в коллекцию");
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при добавлении: " + e.getMessage());
        }
    }
}

//return new ExecutionResponse(arguments.length == 0, arguments.length > 0 ? "Команда 'add' не принимает аргументы" : "OK");package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для очистки коллекции
 */
public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Clear(Console console, CollectionManager collectionManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'clear' не принимает аргументы");
        collectionManager.clear();
        return new ExecutionResponse(true, "Коллекция успешно очищена");
    }
}package commands;

import utility.ExecutionResponse;

/**
 * Абстрактный базовый класс для всех команд
 */
public abstract class Command {
    private final String name;
    private final String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    /**
     * Выполняет команду с переданными аргументами
     * @param arguments аргументы команды
     * @return результат выполнения команды
     */
    public abstract ExecutionResponse apply(String[] arguments);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для подсчета элементов с impactSpeed меньше заданного
 */
public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: impactSpeed");
        try {
            long impactSpeed = Long.parseLong(arguments[0]);
            long count = collectionManager.getCollection().stream()
                    .filter(h -> h.getImpactSpeed() != null && h.getImpactSpeed() < impactSpeed)
                    .count();
            return new ExecutionResponse(true, "Количество элементов: " + count);
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "impactSpeed должен быть числом");
        }
    }
}
package commands;

import managers.CommandManager;
import utility.Console;
import utility.ExecutionResponse;

import java.io.File;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * Команда для выполнения скрипта из файла
 */
public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles;

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "считать и исполнить скрипт из указанного файла");
        this.console = console;
        this.commandManager = commandManager;
        this.executedFiles = new HashSet<>();
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: имя файла");

        File file = new File(arguments[0]);
        String absolutePath;
        try {
            absolutePath = file.getCanonicalPath();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при получении пути файла: " + e.getMessage());
        }

        if (executedFiles.contains(absolutePath)) {
            return new ExecutionResponse(false, "Обнаружена рекурсия: файл '" + absolutePath + "' уже выполняется");
        }

        if (!file.exists() || !file.canRead()) {
            return new ExecutionResponse(false, "Файл не существует или недоступен для чтения");
        }

        executedFiles.add(absolutePath);

        try (Scanner scanner = new Scanner(file)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine().trim();
                if (!line.isEmpty()) {
                    ExecutionResponse response = commandManager.execute(line);
                    console.println(response.getMessage());
                    if (!response.isSuccess() && line.equals("exit")) break;
                }
            }
            executedFiles.remove(absolutePath);
            return new ExecutionResponse(true, "Скрипт успешно выполнен");
        } catch (Exception e) {
            executedFiles.remove(absolutePath);
            return new ExecutionResponse(false, "Ошибка при выполнении скрипта: " + e.getMessage());
        }
    }
}package commands;

import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для завершения работы программы без автоматического сохранения коллекции.
 */
public class Exit extends Command {
    private final Console console;

    /**
     * Создаёт команду Exit с указанной консолью.
     *
     * @param console консоль для вывода сообщений
     */
    public Exit(Console console) {
        super("exit", "завершить программу (без сохранения в файл)");
        this.console = console;
    }

    /**
     * Выполняет команду, завершая программу.
     *
     * @param arguments аргументы команды (не используются)
     * @return результат выполнения команды с сообщением о завершении
     */
    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'exit' не принимает аргументы");
        return new ExecutionResponse(false, "Программа завершена");
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода элементов, имя которых начинается с заданной подстроки
 */
public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: подстрока имени");
        String prefix = arguments[0];
        String result = collectionManager.getCollection().stream()
                .filter(h -> h.getName().startsWith(prefix))
                .map(Object::toString)
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result.isEmpty() ? "Нет элементов с таким именем" : result);
    }
}package commands;

import managers.CommandManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода справки по доступным командам
 */
public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'help' не принимает аргументы");
        StringBuilder sb = new StringBuilder();
        commandManager.getCommands().forEach((name, command) ->
                sb.append(String.format("%s: %s%n", name, command.getDescription())));
        return new ExecutionResponse(true, sb.toString());
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода информации о коллекции
 */
public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'info' не принимает аргументы");
        return new ExecutionResponse(true, collectionManager.getInfo());
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода уникальных значений поля impactSpeed
 */
public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed всех элементов в коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'print_unique_impact_speed' не принимает аргументы");
        String result = collectionManager.getCollection().stream()
                .map(h -> h.getImpactSpeed() == null ? "null" : h.getImpactSpeed().toString())
                .distinct()
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result.isEmpty() ? "Коллекция пуста" : result);
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для удаления элемента по его id
 */
public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("remove_by_id", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: id");
        try {
            long id = Long.parseLong(arguments[0]);
            if (collectionManager.getById(id) == null) return new ExecutionResponse(false, "Элемент с id " + id + " не найден");
            collectionManager.removeById(id);
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "id должен быть числом");
        }
    }
}
package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для удаления первого элемента из коллекции
 */
public class RemoveFirst extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveFirst(Console console, CollectionManager collectionManager) {
        super("remove_first", "удалить первый элемент из коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_first' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(false, "Коллекция пуста");
        collectionManager.getCollection().remove(0);
        return new ExecutionResponse(true, "Первый элемент успешно удален");
    }
}
package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода и удаления первого элемента коллекции
 */
public class RemoveHead extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveHead(Console console, CollectionManager collectionManager) {
        super("remove_head", "вывести первый элемент коллекции и удалить его");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_head' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(false, "Коллекция пуста");
        String head = collectionManager.getCollection().firstElement().toString();
        collectionManager.getCollection().remove(0);
        return new ExecutionResponse(true, "Удален элемент: " + head);
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для удаления всех элементов, меньших заданного.
 */
public class RemoveLower extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public RemoveLower(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("remove_lower", "удалить из коллекции все элементы, меньшие, чем заданный");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_lower' не принимает аргументы в строке");
        try {
            HumanBeing human = asker.askHumanBeing();
            int initialSize = collectionManager.getCollection().size();
            collectionManager.getCollection().removeIf(h -> h.compareTo(human) < 0);
            int removedCount = initialSize - collectionManager.getCollection().size();
            return new ExecutionResponse(true, "Удалено элементов: " + removedCount);
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка: " + e.getMessage());
        }
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для сохранения коллекции в файл
 */
public class Save extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Save(Console console, CollectionManager collectionManager) {
        super("save", "сохранить коллекцию в файл");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'save' не принимает аргументы");
        try {
            collectionManager.saveCollection();
            return new ExecutionResponse(true, "Коллекция успешно сохранена в файл");
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при сохранении коллекции: " + e.getMessage());
        }
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода всех элементов коллекции
 */
public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции в строковом представлении");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'show' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(true, "Коллекция пуста");
        String result = collectionManager.getCollection().stream()
                .map(Object::toString)
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result);
    }
}package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для обновления элемента коллекции по id.
 */
public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public Update(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("update", "обновить значение элемента коллекции, id которого равен заданному");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: id");
        try {
            long id = Long.parseLong(arguments[0]);
            HumanBeing oldHuman = collectionManager.getById(id);
            if (oldHuman == null) return new ExecutionResponse(false, "Элемент с id " + id + " не найден");
            collectionManager.removeById(id);
            HumanBeing newHuman = asker.askHumanBeing(id); // Указываем нужный id
            collectionManager.add(newHuman);
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно обновлён");
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "id должен быть числом");
        }
    }
}package managers;

import models.HumanBeing;
import java.time.LocalDateTime;
import java.util.Vector;

/**
 * Управляет коллекцией объектов {@link HumanBeing}, предоставляя методы для загрузки, сохранения и изменения коллекции.
 */
public class CollectionManager {
    private final Vector<HumanBeing> collection;
    private final LocalDateTime initializationDate;
    private final FileManager fileManager;
    private final IdGenerator idGenerator;

    /**
     * Создаёт новый экземпляр CollectionManager с указанным менеджером файлов.
     * @param fileManager менеджер файлов для загрузки и сохранения
     */
    public CollectionManager(FileManager fileManager) {
        this.collection = new Vector<>();
        this.initializationDate = LocalDateTime.now();
        this.fileManager = fileManager;
        this.idGenerator = new IdGenerator(collection);
        loadCollection();
    }

    private void loadCollection() {
        try {
            Vector<HumanBeing> loaded = fileManager.readCollection();
            collection.addAll(loaded);
            System.out.println("Загружено " + loaded.size() + " элементов из файла:");
            for (HumanBeing human : collection) {
                System.out.println(human);
            }
        } catch (Exception e) {
            System.err.println("Ошибка при загрузке коллекции: " + e.getMessage());
        }
    }

    public void saveCollection() {
        try {
            fileManager.writeCollection(collection);
            System.out.println("Коллекция сохранена в файл. Всего элементов: " + collection.size());
        } catch (Exception e) {
            System.err.println("Ошибка при сохранении: " + e.getMessage());
        }
    }

    /**
     * Генерирует уникальный идентификатор для нового элемента.
     * @return уникальный ID
     */
    public long generateId() {
        return idGenerator.generateId();
    }

    /**
     * Добавляет новый объект в коллекцию с уникальным идентификатором.
     * @param human объект для добавления
     */
    public void add(HumanBeing human) {
        long newId = generateId(); // Генерируем ID только здесь
        human.setId(newId);
        collection.add(human);
        System.out.println("Добавлен элемент с id=" + newId + ": " + human);
    }

    public void removeById(long id) { collection.removeIf(h -> h.getId() == id); }
    public void clear() { collection.clear(); }
    public HumanBeing getById(long id) { return collection.stream().filter(h -> h.getId() == id).findFirst().orElse(null); }
    public Vector<HumanBeing> getCollection() { return collection; }
    public String getInfo() {
        return String.format("Тип: %s, Дата инициализации: %s, Количество элементов: %d",
                collection.getClass().getSimpleName(), initializationDate, collection.size());
    }
}package managers;

import commands.*;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

import java.util.HashMap;
import java.util.Map;

/**
 * Менеджер команд.
 */
public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(CollectionManager collectionManager, Console console) {
        this.console = console;
        HumanBeingAsker asker = new HumanBeingAsker(console);
        commands.put("help", new Help(console, this));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("add", new Add(console, collectionManager, asker));
        commands.put("update", new Update(console, collectionManager, asker));
        commands.put("remove_by_id", new RemoveById(console, collectionManager));
        commands.put("clear", new Clear(console, collectionManager));
        commands.put("save", new Save(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("exit", new Exit(console));
        commands.put("remove_first", new RemoveFirst(console, collectionManager));
        commands.put("remove_head", new RemoveHead(console, collectionManager));
        commands.put("remove_lower", new RemoveLower(console, collectionManager, asker));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
    }

    public ExecutionResponse execute(String commandLine) {
        if (commandLine.isEmpty()) return new ExecutionResponse(false, "Команда не введена");
        String[] parts = commandLine.trim().split("\\s+", 2);
        String commandName = parts[0];
        String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];

        Command command = commands.get(commandName);
        if (command == null) return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена");
        return command.apply(args);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}package managers;

import models.*;

/**
 * Содержит статические методы для преобразования строк CSV в объекты {@link HumanBeing} и обратно.
 */
public class CsvParser {

    /**
     * Преобразует строку CSV в объект {@link HumanBeing}.
     *
     * @param csvLine строка CSV, содержащая данные об объекте
     * @return объект {@link HumanBeing} или выбрасывает исключение при некорректных данных
     * @throws IllegalArgumentException если данные в строке некорректны
     */
    public static HumanBeing parseHumanBeing(String csvLine) {
        String[] parts = csvLine.split(",", -1);
        if (parts.length < 10 || parts.length > 11) {
            System.err.println("Неверное количество полей: " + parts.length + " (ожидается 10 или 11) в строке: " + csvLine);
            return null;
        }

        try {
            long id = Long.parseLong(parts[0].trim());
            if (id <= 0) throw new IllegalArgumentException("id должен быть больше 0");

            String name = parts[1].trim();
            if (name.isEmpty()) throw new IllegalArgumentException("name не может быть пустым");

            String xStr = parts[2].trim().replace(",", ".");
            float x = Float.parseFloat(xStr);

            int y = Integer.parseInt(parts[3].trim());

            boolean realHero = Boolean.parseBoolean(parts[5].trim());

            String hasToothpickStr = parts[6].trim();
            if (hasToothpickStr.isEmpty()) throw new IllegalArgumentException("hasToothpick не может быть пустым");
            Boolean hasToothpick = Boolean.parseBoolean(hasToothpickStr);

            String impactSpeedStr = parts[7].trim();
            Long impactSpeed = impactSpeedStr.isEmpty() ? null : Long.parseLong(impactSpeedStr);

            String weaponTypeStr = parts[8].trim();
            WeaponType weaponType = weaponTypeStr.isEmpty() ? null : WeaponType.valueOf(weaponTypeStr.toUpperCase());

            String moodStr = parts[9].trim();
            Mood mood = moodStr.isEmpty() ? null : Mood.valueOf(moodStr.toUpperCase());

            String carName = parts.length > 10 ? parts[10].trim() : null;
            if (carName != null && carName.isEmpty()) carName = null;

            Coordinates coordinates = new Coordinates(x, y);
            Car car = new Car(carName);
            return new HumanBeing(id, name, coordinates, realHero, hasToothpick, impactSpeed, weaponType, mood, car);
        } catch (Exception e) {
            throw new IllegalArgumentException("Некорректные данные в строке '" + csvLine + "': " + e.getMessage());
        }
    }

    /**
     * Преобразует объект {@link HumanBeing} в строку CSV.
     *
     * @param human объект для преобразования
     * @return строка CSV, представляющая объект
     */
    public static String humanToCsv(HumanBeing human) {
        return String.format("%d,%s,%.1f,%d,%b,%s,%s,%s,%s,%s",
                human.getId(), human.getName(), human.getCoordinates().getX(), human.getCoordinates().getY(),
                human.isRealHero(), human.getHasToothpick(),
                human.getImpactSpeed() == null ? "" : human.getImpactSpeed(),
                human.getWeaponType() == null ? "" : human.getWeaponType(),
                human.getMood() == null ? "" : human.getMood(),
                human.getCar().getName() == null ? "" : human.getCar().getName());
    }
}package managers;

import models.*;
import java.io.*;
import java.util.Vector;

/**
 * Управляет чтением и записью коллекции объектов {@link HumanBeing} в CSV-файл.
 * Реализует интерфейс {@link FileManager}.
 */
public class DumpManager implements FileManager {
    private final String fileName;

    /**
     * Создаёт экземпляр DumpManager, используя путь к файлу из переменной окружения COLLECTION_FILE.
     *
     * @throws IllegalStateException если переменная окружения COLLECTION_FILE не установлена
     */
    public DumpManager() {
        this.fileName = System.getenv("COLLECTION_FILE");
        if (fileName == null || fileName.isEmpty()) {
            throw new IllegalStateException("Переменная окружения COLLECTION_FILE не установлена");
        }
        System.out.println("Используемый файл: " + fileName);
    }

    /**
     * Считывает коллекцию объектов {@link HumanBeing} из настроенного CSV-файла.
     *
     * @return {@link Vector}, содержащий загруженные объекты {@link HumanBeing}
     * @throws IOException если произошла ошибка ввода-вывода при чтении файла
     */
    @Override
    public Vector<HumanBeing> readCollection() throws IOException {
        Vector<HumanBeing> collection = new Vector<>();
        File file = new File(fileName);
        if (!file.exists()) {
            System.out.println("Файл не существует: " + fileName);
            return collection;
        }
        if (!file.canRead()) throw new IOException("Нет прав на чтение файла: " + fileName);

        System.out.println("Читаем файл: " + fileName);
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            int lineNumber = 0;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                lineNumber++;
                if (!line.isEmpty()) {
                    System.out.println("Прочитана строка " + lineNumber + ": " + line);
                    try {
                        HumanBeing human = CsvParser.parseHumanBeing(line);
                        if (human != null) {
                            collection.add(human);
                            System.out.println("Добавлен объект: " + human);
                        } else {
                            System.out.println("Строка " + lineNumber + " вернула null");
                        }
                    } catch (Exception e) {
                        System.err.println("Ошибка парсинга строки " + lineNumber + ": " + line + " (" + e.getMessage() + ")");
                    }
                } else {
                    System.out.println("Пропущена пустая строка " + lineNumber);
                }
            }
            if (lineNumber == 0) {
                System.out.println("Файл пустой или не удалось прочитать ни одной строки");
            }
        }
        return collection;
    }

    /**
     * Записывает коллекцию объектов {@link HumanBeing} в настроенный CSV-файл.
     *
     * @param collection коллекция для записи
     * @throws IOException если произошла ошибка ввода-вывода при записи в файл
     */
    @Override
    public void writeCollection(Vector<HumanBeing> collection) throws IOException {
        File file = new File(fileName);
        File parentDir = file.getParentFile();
        if (parentDir != null && !parentDir.exists()) parentDir.mkdirs();
        if (file.exists() && !file.canWrite()) throw new IOException("Нет прав на запись: " + fileName);

        try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
            for (HumanBeing human : collection) {
                String csvLine = CsvParser.humanToCsv(human);
                writer.println(csvLine);
                System.out.println("Записана строка: " + csvLine);
            }
        }
    }
}package managers;

import models.HumanBeing;
import java.util.Vector;

/**
 * интерфейс для работы с файлами
 */
public interface FileManager {
    Vector<HumanBeing> readCollection() throws java.io.IOException;
    void writeCollection(Vector<HumanBeing> collection) throws java.io.IOException;
}
package managers;

import models.HumanBeing;
import java.util.Vector;

/**
 * Генерирует уникальные идентификаторы для объектов {@link HumanBeing} на основе существующих идентификаторов в коллекции.
 */
public class IdGenerator {
    private long nextId;
    private final Vector<HumanBeing> collection;

    /**
     * Создаёт генератор идентификаторов для указанной коллекции.
     * Устанавливает следующий идентификатор как значение, превышающее максимальный существующий.
     *
     * @param collection коллекция объектов {@link HumanBeing}, на основе которой генерируются идентификаторы
     */
    public IdGenerator(Vector<HumanBeing> collection) {
        this.collection = collection;
        if (collection.isEmpty()) {
            nextId = 1;
        } else {
            nextId = collection.stream()
                    .mapToLong(HumanBeing::getId)
                    .max()
                    .getAsLong() + 1;
        }
        System.out.println("Инициализирован IdGenerator с nextId = " + nextId);
    }

    /**
     * Генерирует уникальный идентификатор для нового объекта {@link HumanBeing}.
     * Гарантирует, что идентификатор не совпадает с уже существующими в коллекции.
     *
     * @return уникальный идентификатор
     */
    public long generateId() {
        while (collection.stream().anyMatch(h -> h.getId() == nextId)) {
            nextId++;
        }
        long id = nextId;
        nextId++;
        System.out.println("Сгенерирован новый id: " + id);
        return id;
    }
}package models;

/**
 * Класс автомобиля
 */
public class Car {
    private String name; // Поле может быть null

    /**
     * Конструктор класса Car
     * @param name имя автомобиля
     */
    public Car(String name) {
        this.name = name;
    }

    public String getName() { return name; }

    /**
     * Возвращает строковое представление объекта
     * @return строка с именем автомобиля
     */
    @Override
    public String toString() {
        return String.format("Car{name='%s'}", name == null ? "null" : name);
    }
}package models;

import utility.Validatable;

/**
 * Представляет координаты объекта с полями x и y.
 */
public class Coordinates implements Validatable {
    private float x; // Значение поля должно быть больше -89
    private int y;  // Значение поля должно быть больше -862

    /**
     * Создаёт новый объект Coordinates с указанными значениями x и y.
     * @param x координата x, должна быть больше -89
     * @param y координата y, должна быть больше -862
     */
    public Coordinates(float x, int y) {
        this.x = x;
        this.y = y;
    }

    public float getX() { return x; }
    public int getY() { return y; }

    /**
     * Проверяет валидность координат: x > -89, y > -862.
     * @return true, если координаты валидны, иначе false
     */
    @Override
    public boolean validate() {
        if (x <= -89) {
            System.out.println("Ошибка: x должен быть больше -89. Текущее значение: " + x);
            return false;
        }
        if (y <= -862) {
            System.out.println("Ошибка: y должен быть больше -862. Текущее значение: " + y);
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "Coordinates{x=" + x + ", y=" + y + "}";
    }
}package models;

import java.time.LocalDateTime;

/**
 * Представляет объект "человек" с изменяемым идентификатором и набором неизменяемых характеристик.
 */
public class HumanBeing implements Comparable<HumanBeing> {
    private long id;
    private final HumanBeingData data;

    private record HumanBeingData(
            String name,
            Coordinates coordinates,
            LocalDateTime creationDate,
            boolean realHero,
            Boolean hasToothpick,
            Long impactSpeed,
            WeaponType weaponType,
            Mood mood,
            Car car
    ) {}

    public HumanBeing(long id, String name, Coordinates coordinates, boolean realHero, Boolean hasToothpick,
                      Long impactSpeed, WeaponType weaponType, Mood mood, Car car) {
        this.id = id;
        this.data = new HumanBeingData(name, coordinates, LocalDateTime.now(), realHero, hasToothpick,
                impactSpeed, weaponType, mood, car);
    }

    public void setId(long id) {
        this.id = id;
    }

    public long getId() {
        return id;
    }

    public String getName() {
        return data.name();
    }

    public Coordinates getCoordinates() {
        return data.coordinates();
    }

    public LocalDateTime getCreationDate() {
        return data.creationDate();
    }

    public boolean isRealHero() {
        return data.realHero();
    }

    public Boolean getHasToothpick() {
        return data.hasToothpick();
    }

    public Long getImpactSpeed() {
        return data.impactSpeed();
    }

    public WeaponType getWeaponType() {
        return data.weaponType();
    }

    public Mood getMood() {
        return data.mood();
    }

    public Car getCar() {
        return data.car();
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.id, other.id);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + data.name() + '\'' +
                ", coordinates=" + data.coordinates() +
                ", creationDate=" + data.creationDate() +
                ", realHero=" + data.realHero() +
                ", hasToothpick=" + data.hasToothpick() +
                ", impactSpeed=" + data.impactSpeed() +
                ", weaponType=" + data.weaponType() +
                ", mood=" + data.mood() +
                ", car=" + data.car() +
                '}';
    }
}package models;

/**
 * Перечисление настроений
 */
public enum Mood {
    SADNESS,
    LONGING,
    APATHY,
    CALM,
    RAGE;
}package models;

/**
 * Перечисление типов оружия
 */
public enum WeaponType {
    PISTOL,
    SHOTGUN,
    KNIFE,
    MACHINE_GUN;
}package utility;

/**
 * Интерфейс для взаимодействия с консолью.
 */
public interface Console {
    /**
     * Выводит сообщение в консоль.
     * @param message сообщение для вывода
     */
    void println(String message);

    /**
     * Считывает строку из консоли.
     * @return введённая строка или null при конце ввода
     */
    String readln();
}package utility;

/**
 * Результат выполнения команды
 */
public class ExecutionResponse {
    private final boolean success;
    private final String message;

    /**
     * Конструктор результата выполнения команды
     * @param success флаг успешности выполнения
     * @param message сообщение с результатом
     */
    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    /**
     * Проверяет, успешно ли выполнена команда
     * @return true, если команда выполнена успешно
     */
    public boolean isSuccess() {
        return success;
    }

    /**
     * Возвращает сообщение с результатом выполнения
     * @return сообщение
     */
    public String getMessage() {
        return message;
    }
}package utility;

import models.*;

import java.util.Arrays;

/**
 * Класс для ввода данных и создания объекта {@link HumanBeing}.
 */
public class HumanBeingAsker {
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    /**
     * Запрашивает данные для создания объекта {@link HumanBeing}.
     * @return новый объект HumanBeing с указанным id или новым, если id = 0
     */
    public HumanBeing askHumanBeing(long id) {
        console.println("Введите name:");
        String name = askNonEmptyString("Ошибка: name не может быть пустым. Повторите ввод:");

        Coordinates coordinates = askCoordinates();

        console.println("realHero (true/false):");
        boolean realHero = askBoolean();

        console.println("hasToothpick (true/false):");
        Boolean hasToothpick = askBoolean();

        console.println("impactSpeed (число или пустая строка для null):");
        Long impactSpeed = askLongOrNull();

        console.println("weaponType (PISTOL, SHOTGUN, KNIFE, MACHINE_GUN или пустая строка для null):");
        console.println("Доступные значения: " + Arrays.toString(WeaponType.values()));
        WeaponType weaponType = askEnumOrNull(WeaponType.class);

        console.println("mood (SADNESS, LONGING, APATHY, CALM, RAGE или пустая строка для null):");
        console.println("Доступные значения: " + Arrays.toString(Mood.values()));
        Mood mood = askEnumOrNull(Mood.class);

        console.println("car name (или пустая строка для null):");
        String carName = console.readln();
        while (carName == null) {
            console.println("Для выхода используйте команду exit.");
            console.println("car name (или пустая строка для null):");
            carName = console.readln();
        }
        Car car = new Car(carName.isEmpty() ? null : carName);

        return new HumanBeing(id, name, coordinates, realHero, hasToothpick, impactSpeed, weaponType, mood, car);
    }

    /**
     * Запрашивает данные для создания объекта {@link HumanBeing} без указания id.
     */
    public HumanBeing askHumanBeing() {
        return askHumanBeing(0); // id будет установлен в CollectionManager.add()
    }

    private Coordinates askCoordinates() {
        while (true) {
            console.println("Введите x:");
            Float x = askFloat();
            if (x == null) continue;

            console.println("Введите y:");
            Integer y = askInteger();
            if (y == null) continue;

            Coordinates coordinates = new Coordinates(x, y);
            if (coordinates.validate()) {
                return coordinates;
            }
            console.println("Повторите ввод:");
        }
    }

    private String askNonEmptyString(String errorMessage) {
        String input = console.readln();
        while (input == null || input.isEmpty()) {
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
            } else {
                console.println(errorMessage);
            }
            console.println("Введите значение:");
            input = console.readln();
        }
        return input;
    }

    private boolean askBoolean() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите true или false:");
                continue;
            }
            input = input.toLowerCase();
            if ("true".equals(input)) return true;
            if ("false".equals(input)) return false;
            console.println("Ошибка: введите true или false. Повторите ввод:");
        }
    }

    private Long askLongOrNull() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите число или пустую строку для null:");
                continue;
            }
            if (input.isEmpty()) return null;
            try {
                return Long.parseLong(input);
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите число или пустую строку. Повторите ввод:");
            }
        }
    }

    private <T extends Enum<T>> T askEnumOrNull(Class<T> enumClass) {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите значение или пустую строку для null:");
                console.println("Доступные значения: " + Arrays.toString(enumClass.getEnumConstants()));
                continue;
            }
            if (input.isEmpty()) return null;
            try {
                return Enum.valueOf(enumClass, input.toUpperCase());
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: введите одно из указанных значений или пустую строку. Повторите ввод:");
            }
        }
    }

    private Float askFloat() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите x:");
                return null;
            }
            try {
                return Float.parseFloat(input.replace(",", "."));
            } catch (NumberFormatException e) {
                console.println("Ошибка: x должен быть числом с плавающей точкой. Повторите ввод:");
            }
        }
    }

    private Integer askInteger() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите y:");
                return null;
            }
            try {
                return Integer.parseInt(input);
            } catch (NumberFormatException e) {
                console.println("Ошибка: y должен быть целым числом. Повторите ввод:");
            }
        }
    }
}package utility;

import managers.CommandManager;

/**
 * Класс для запуска интерактивного режима программы, обрабатывающий команды пользователя через {@link CommandManager}.
 * Предоставляет консольный интерфейс для взаимодействия с коллекцией.
 */
public class Runner {
    private final CommandManager commandManager;
    private final Console console;
    private boolean receivedEOF = false;
    private volatile boolean normalExit = false;

    /**
     * Создаёт новый экземпляр {@link Runner} с указанными менеджером команд и консолью.
     * Настраивает обработку прерывания программы (Ctrl+C) для вывода сообщения о несохранённых данных.
     *
     * @param commandManager менеджер команд для обработки пользовательского ввода
     * @param console консоль для вывода сообщений и чтения ввода пользователя
     */
    public Runner(CommandManager commandManager, Console console) {
        this.commandManager = commandManager;
        this.console = console;

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if (!normalExit) {
                console.println("\nПрограмма прервана (Ctrl+C). Данные не сохранены.");
            }
        }));
    }

    /**
     * Запускает интерактивный режим программы, выводя инструкции и ожидая ввода команд от пользователя.
     * Завершает работу при выполнении команды "exit" или при возникновении ошибки.
     */
    public void interactiveMode() {
        console.println("Добро пожаловать в программу управления коллекцией!");
        console.println("инструкции по управлению в терминале:");
        console.println("- Ctrl+D: Сигнал конца ввода. Программа выведет сообщение и продолжит работу.");
        console.println("- Ctrl+C: Немедленно прерывает программу без сохранения данных.");
        console.println("- Ctrl+Z: Приостанавливает программу и переводит её в фон. Для возобновления введите 'fg'.");
        console.println("- Ctrl+S: Приостанавливает вывод в терминал. Нажмите Ctrl+Q для возобновления.");
        console.println("Введите команду (help для списка команд):");

        while (true) {
            String input = console.readln();
            if (input == null) {
                if (!receivedEOF) {
                    console.println("Для выхода из программы используйте команду exit.");
                    receivedEOF = true;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    console.println("Ошибка: " + e.getMessage());
                }
                continue;
            }
            receivedEOF = false;
            try {
                ExecutionResponse response = commandManager.execute(input);
                console.println(response.getMessage());
                if (!response.isSuccess() && input.equals("exit")) {
                    normalExit = true;
                    break;
                }
            } catch (Exception e) {
                console.println("Произошла ошибка: " + e.getMessage());
                console.println("Введите команду (help для списка команд):");
            }
            console.println("Введите команду (help для списка команд):");
        }
    }
}package utility;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * Стандартная реализация консоли для ввода-вывода через System.in и System.out.
 * Поддерживает чтение из файла при выполнении скрипта.
 */
public class StandardConsole implements Console {
    private BufferedReader reader;
    private Scanner scriptScanner;

    public StandardConsole() {
        this.reader = new BufferedReader(new InputStreamReader(System.in));
        this.scriptScanner = null; // По умолчанию читаем с клавиатуры
    }

    /**
     * Устанавливает источник ввода для скрипта.
     * @param scanner сканнер для чтения из файла скрипта
     */
    public void setScriptScanner(Scanner scanner) {
        this.scriptScanner = scanner;
    }

    /**
     * Сбрасывает источник ввода на клавиатуру.
     */
    public void clearScriptScanner() {
        this.scriptScanner = null;
    }

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String readln() {
        try {
            if (scriptScanner != null && scriptScanner.hasNextLine()) {
                String line = scriptScanner.nextLine().trim();
                println("> " + line); // Эхо ввода для отладки
                return line;
            } else {
                String line = reader.readLine();
                return line != null ? line.trim() : null;
            }
        } catch (Exception e) {
            println("Ошибка ввода: " + e.getMessage());
            return null;
        }
    }

    /**
     * Проверяет, выполняется ли сейчас скрипт.
     * @return true, если читаем из скрипта
     */
    public boolean isScriptMode() {
        return scriptScanner != null;
    }
}package utility;

/**
 * интерфейс для классов, поля которых могут быть валидными или нет.
 */
public interface Validatable {
    boolean validate();
}
import managers.CollectionManager;
import managers.CommandManager;
import managers.DumpManager;
import managers.FileManager;
import utility.Console;
import utility.Runner;
import utility.StandardConsole;

/**
 * Главный класс приложения
 */
public class Main {
    public static void main(String[] args) {
        try {
            Console console = new StandardConsole();
            FileManager fileManager = new DumpManager();
            CollectionManager collectionManager = new CollectionManager(fileManager);
            CommandManager commandManager = new CommandManager(collectionManager, console);
            Runner runner = new Runner(commandManager, console);
            runner.interactiveMode();
        } catch (Exception e) {
            System.err.println("Ошибка инициализации: " + e.getMessage());
            System.exit(1);
        }
    }
}package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для добавления нового элемента в коллекцию.
 */
public class Add extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public Add(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("add", "добавить новый элемент в коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'add' не принимает аргументы");
        try {
            HumanBeing human = asker.askHumanBeing();
            collectionManager.add(human); // ID генерируется внутри add
            return new ExecutionResponse(true, "Элемент успешно добавлен в коллекцию");
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при добавлении: " + e.getMessage());
        }
    }
}

//return new ExecutionResponse(arguments.length == 0, arguments.length > 0 ? "Команда 'add' не принимает аргументы" : "OK");package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для очистки коллекции
 */
public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Clear(Console console, CollectionManager collectionManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'clear' не принимает аргументы");
        collectionManager.clear();
        return new ExecutionResponse(true, "Коллекция успешно очищена");
    }
}package commands;

import utility.ExecutionResponse;

/**
 * Абстрактный базовый класс для всех команд
 */
public abstract class Command {
    private final String name;
    private final String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    /**
     * Выполняет команду с переданными аргументами
     * @param arguments аргументы команды
     * @return результат выполнения команды
     */
    public abstract ExecutionResponse apply(String[] arguments);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для подсчета элементов с impactSpeed меньше заданного
 */
public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: impactSpeed");
        try {
            long impactSpeed = Long.parseLong(arguments[0]);
            long count = collectionManager.getCollection().stream()
                    .filter(h -> h.getImpactSpeed() != null && h.getImpactSpeed() < impactSpeed)
                    .count();
            return new ExecutionResponse(true, "Количество элементов: " + count);
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "impactSpeed должен быть числом");
        }
    }
}
package commands;

import managers.CommandManager;
import utility.Console;
import utility.ExecutionResponse;

import java.io.File;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * Команда для выполнения скрипта из файла
 */
public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles;

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "считать и исполнить скрипт из указанного файла");
        this.console = console;
        this.commandManager = commandManager;
        this.executedFiles = new HashSet<>();
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: имя файла");

        File file = new File(arguments[0]);
        String absolutePath;
        try {
            absolutePath = file.getCanonicalPath();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при получении пути файла: " + e.getMessage());
        }

        if (executedFiles.contains(absolutePath)) {
            return new ExecutionResponse(false, "Обнаружена рекурсия: файл '" + absolutePath + "' уже выполняется");
        }

        if (!file.exists() || !file.canRead()) {
            return new ExecutionResponse(false, "Файл не существует или недоступен для чтения");
        }

        executedFiles.add(absolutePath);

        try (Scanner scanner = new Scanner(file)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine().trim();
                if (!line.isEmpty()) {
                    ExecutionResponse response = commandManager.execute(line);
                    console.println(response.getMessage());
                    if (!response.isSuccess() && line.equals("exit")) break;
                }
            }
            executedFiles.remove(absolutePath);
            return new ExecutionResponse(true, "Скрипт успешно выполнен");
        } catch (Exception e) {
            executedFiles.remove(absolutePath);
            return new ExecutionResponse(false, "Ошибка при выполнении скрипта: " + e.getMessage());
        }
    }
}package commands;

import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для завершения работы программы без автоматического сохранения коллекции.
 */
public class Exit extends Command {
    private final Console console;

    /**
     * Создаёт команду Exit с указанной консолью.
     *
     * @param console консоль для вывода сообщений
     */
    public Exit(Console console) {
        super("exit", "завершить программу (без сохранения в файл)");
        this.console = console;
    }

    /**
     * Выполняет команду, завершая программу.
     *
     * @param arguments аргументы команды (не используются)
     * @return результат выполнения команды с сообщением о завершении
     */
    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'exit' не принимает аргументы");
        return new ExecutionResponse(false, "Программа завершена");
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода элементов, имя которых начинается с заданной подстроки
 */
public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: подстрока имени");
        String prefix = arguments[0];
        String result = collectionManager.getCollection().stream()
                .filter(h -> h.getName().startsWith(prefix))
                .map(Object::toString)
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result.isEmpty() ? "Нет элементов с таким именем" : result);
    }
}package commands;

import managers.CommandManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода справки по доступным командам
 */
public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'help' не принимает аргументы");
        StringBuilder sb = new StringBuilder();
        commandManager.getCommands().forEach((name, command) ->
                sb.append(String.format("%s: %s%n", name, command.getDescription())));
        return new ExecutionResponse(true, sb.toString());
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода информации о коллекции
 */
public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'info' не принимает аргументы");
        return new ExecutionResponse(true, collectionManager.getInfo());
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода уникальных значений поля impactSpeed
 */
public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed всех элементов в коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'print_unique_impact_speed' не принимает аргументы");
        String result = collectionManager.getCollection().stream()
                .map(h -> h.getImpactSpeed() == null ? "null" : h.getImpactSpeed().toString())
                .distinct()
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result.isEmpty() ? "Коллекция пуста" : result);
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для удаления элемента по его id
 */
public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("remove_by_id", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: id");
        try {
            long id = Long.parseLong(arguments[0]);
            if (collectionManager.getById(id) == null) return new ExecutionResponse(false, "Элемент с id " + id + " не найден");
            collectionManager.removeById(id);
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "id должен быть числом");
        }
    }
}
package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для удаления первого элемента из коллекции
 */
public class RemoveFirst extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveFirst(Console console, CollectionManager collectionManager) {
        super("remove_first", "удалить первый элемент из коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_first' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(false, "Коллекция пуста");
        collectionManager.getCollection().remove(0);
        return new ExecutionResponse(true, "Первый элемент успешно удален");
    }
}
package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода и удаления первого элемента коллекции
 */
public class RemoveHead extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveHead(Console console, CollectionManager collectionManager) {
        super("remove_head", "вывести первый элемент коллекции и удалить его");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_head' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(false, "Коллекция пуста");
        String head = collectionManager.getCollection().firstElement().toString();
        collectionManager.getCollection().remove(0);
        return new ExecutionResponse(true, "Удален элемент: " + head);
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для удаления всех элементов, меньших заданного.
 */
public class RemoveLower extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public RemoveLower(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("remove_lower", "удалить из коллекции все элементы, меньшие, чем заданный");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'remove_lower' не принимает аргументы в строке");
        try {
            HumanBeing human = asker.askHumanBeing();
            int initialSize = collectionManager.getCollection().size();
            collectionManager.getCollection().removeIf(h -> h.compareTo(human) < 0);
            int removedCount = initialSize - collectionManager.getCollection().size();
            return new ExecutionResponse(true, "Удалено элементов: " + removedCount);
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка: " + e.getMessage());
        }
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для сохранения коллекции в файл
 */
public class Save extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Save(Console console, CollectionManager collectionManager) {
        super("save", "сохранить коллекцию в файл");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'save' не принимает аргументы");
        try {
            collectionManager.saveCollection();
            return new ExecutionResponse(true, "Коллекция успешно сохранена в файл");
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка при сохранении коллекции: " + e.getMessage());
        }
    }
}package commands;

import managers.CollectionManager;
import utility.Console;
import utility.ExecutionResponse;

/**
 * Команда для вывода всех элементов коллекции
 */
public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции в строковом представлении");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length > 0) return new ExecutionResponse(false, "Команда 'show' не принимает аргументы");
        if (collectionManager.getCollection().isEmpty()) return new ExecutionResponse(true, "Коллекция пуста");
        String result = collectionManager.getCollection().stream()
                .map(Object::toString)
                .collect(java.util.stream.Collectors.joining("\n"));
        return new ExecutionResponse(true, result);
    }
}package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

/**
 * Команда для обновления элемента коллекции по id.
 */
public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final HumanBeingAsker asker;

    public Update(Console console, CollectionManager collectionManager, HumanBeingAsker asker) {
        super("update", "обновить значение элемента коллекции, id которого равен заданному");
        this.console = console;
        this.collectionManager = collectionManager;
        this.asker = asker;
    }

    @Override
    public ExecutionResponse apply(String[] arguments) {
        if (arguments.length != 1) return new ExecutionResponse(false, "Команда требует один аргумент: id");
        try {
            long id = Long.parseLong(arguments[0]);
            HumanBeing oldHuman = collectionManager.getById(id);
            if (oldHuman == null) return new ExecutionResponse(false, "Элемент с id " + id + " не найден");
            collectionManager.removeById(id);
            HumanBeing newHuman = asker.askHumanBeing(id); // Указываем нужный id
            collectionManager.add(newHuman);
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно обновлён");
        } catch (NumberFormatException e) {
            return new ExecutionResponse(false, "id должен быть числом");
        }
    }
}package managers;

import models.HumanBeing;
import java.time.LocalDateTime;
import java.util.Vector;

/**
 * Управляет коллекцией объектов {@link HumanBeing}, предоставляя методы для загрузки, сохранения и изменения коллекции.
 */
public class CollectionManager {
    private final Vector<HumanBeing> collection;
    private final LocalDateTime initializationDate;
    private final FileManager fileManager;
    private final IdGenerator idGenerator;

    /**
     * Создаёт новый экземпляр CollectionManager с указанным менеджером файлов.
     * @param fileManager менеджер файлов для загрузки и сохранения
     */
    public CollectionManager(FileManager fileManager) {
        this.collection = new Vector<>();
        this.initializationDate = LocalDateTime.now();
        this.fileManager = fileManager;
        this.idGenerator = new IdGenerator(collection);
        loadCollection();
    }

    private void loadCollection() {
        try {
            Vector<HumanBeing> loaded = fileManager.readCollection();
            collection.addAll(loaded);
            System.out.println("Загружено " + loaded.size() + " элементов из файла:");
            for (HumanBeing human : collection) {
                System.out.println(human);
            }
        } catch (Exception e) {
            System.err.println("Ошибка при загрузке коллекции: " + e.getMessage());
        }
    }

    public void saveCollection() {
        try {
            fileManager.writeCollection(collection);
            System.out.println("Коллекция сохранена в файл. Всего элементов: " + collection.size());
        } catch (Exception e) {
            System.err.println("Ошибка при сохранении: " + e.getMessage());
        }
    }

    /**
     * Генерирует уникальный идентификатор для нового элемента.
     * @return уникальный ID
     */
    public long generateId() {
        return idGenerator.generateId();
    }

    /**
     * Добавляет новый объект в коллекцию с уникальным идентификатором.
     * @param human объект для добавления
     */
    public void add(HumanBeing human) {
        long newId = generateId(); // Генерируем ID только здесь
        human.setId(newId);
        collection.add(human);
        System.out.println("Добавлен элемент с id=" + newId + ": " + human);
    }

    public void removeById(long id) { collection.removeIf(h -> h.getId() == id); }
    public void clear() { collection.clear(); }
    public HumanBeing getById(long id) { return collection.stream().filter(h -> h.getId() == id).findFirst().orElse(null); }
    public Vector<HumanBeing> getCollection() { return collection; }
    public String getInfo() {
        return String.format("Тип: %s, Дата инициализации: %s, Количество элементов: %d",
                collection.getClass().getSimpleName(), initializationDate, collection.size());
    }
}package managers;

import commands.*;
import utility.Console;
import utility.ExecutionResponse;
import utility.HumanBeingAsker;

import java.util.HashMap;
import java.util.Map;

/**
 * Менеджер команд.
 */
public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(CollectionManager collectionManager, Console console) {
        this.console = console;
        HumanBeingAsker asker = new HumanBeingAsker(console);
        commands.put("help", new Help(console, this));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("add", new Add(console, collectionManager, asker));
        commands.put("update", new Update(console, collectionManager, asker));
        commands.put("remove_by_id", new RemoveById(console, collectionManager));
        commands.put("clear", new Clear(console, collectionManager));
        commands.put("save", new Save(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("exit", new Exit(console));
        commands.put("remove_first", new RemoveFirst(console, collectionManager));
        commands.put("remove_head", new RemoveHead(console, collectionManager));
        commands.put("remove_lower", new RemoveLower(console, collectionManager, asker));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
    }

    public ExecutionResponse execute(String commandLine) {
        if (commandLine.isEmpty()) return new ExecutionResponse(false, "Команда не введена");
        String[] parts = commandLine.trim().split("\\s+", 2);
        String commandName = parts[0];
        String[] args = parts.length > 1 ? parts[1].split("\\s+") : new String[0];

        Command command = commands.get(commandName);
        if (command == null) return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена");
        return command.apply(args);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}package managers;

import models.*;

/**
 * Содержит статические методы для преобразования строк CSV в объекты {@link HumanBeing} и обратно.
 */
public class CsvParser {

    /**
     * Преобразует строку CSV в объект {@link HumanBeing}.
     *
     * @param csvLine строка CSV, содержащая данные об объекте
     * @return объект {@link HumanBeing} или выбрасывает исключение при некорректных данных
     * @throws IllegalArgumentException если данные в строке некорректны
     */
    public static HumanBeing parseHumanBeing(String csvLine) {
        String[] parts = csvLine.split(",", -1);
        if (parts.length < 10 || parts.length > 11) {
            System.err.println("Неверное количество полей: " + parts.length + " (ожидается 10 или 11) в строке: " + csvLine);
            return null;
        }

        try {
            long id = Long.parseLong(parts[0].trim());
            if (id <= 0) throw new IllegalArgumentException("id должен быть больше 0");

            String name = parts[1].trim();
            if (name.isEmpty()) throw new IllegalArgumentException("name не может быть пустым");

            String xStr = parts[2].trim().replace(",", ".");
            float x = Float.parseFloat(xStr);

            int y = Integer.parseInt(parts[3].trim());

            boolean realHero = Boolean.parseBoolean(parts[5].trim());

            String hasToothpickStr = parts[6].trim();
            if (hasToothpickStr.isEmpty()) throw new IllegalArgumentException("hasToothpick не может быть пустым");
            Boolean hasToothpick = Boolean.parseBoolean(hasToothpickStr);

            String impactSpeedStr = parts[7].trim();
            Long impactSpeed = impactSpeedStr.isEmpty() ? null : Long.parseLong(impactSpeedStr);

            String weaponTypeStr = parts[8].trim();
            WeaponType weaponType = weaponTypeStr.isEmpty() ? null : WeaponType.valueOf(weaponTypeStr.toUpperCase());

            String moodStr = parts[9].trim();
            Mood mood = moodStr.isEmpty() ? null : Mood.valueOf(moodStr.toUpperCase());

            String carName = parts.length > 10 ? parts[10].trim() : null;
            if (carName != null && carName.isEmpty()) carName = null;

            Coordinates coordinates = new Coordinates(x, y);
            Car car = new Car(carName);
            return new HumanBeing(id, name, coordinates, realHero, hasToothpick, impactSpeed, weaponType, mood, car);
        } catch (Exception e) {
            throw new IllegalArgumentException("Некорректные данные в строке '" + csvLine + "': " + e.getMessage());
        }
    }

    /**
     * Преобразует объект {@link HumanBeing} в строку CSV.
     *
     * @param human объект для преобразования
     * @return строка CSV, представляющая объект
     */
    public static String humanToCsv(HumanBeing human) {
        return String.format("%d,%s,%.1f,%d,%b,%s,%s,%s,%s,%s",
                human.getId(), human.getName(), human.getCoordinates().getX(), human.getCoordinates().getY(),
                human.isRealHero(), human.getHasToothpick(),
                human.getImpactSpeed() == null ? "" : human.getImpactSpeed(),
                human.getWeaponType() == null ? "" : human.getWeaponType(),
                human.getMood() == null ? "" : human.getMood(),
                human.getCar().getName() == null ? "" : human.getCar().getName());
    }
}package managers;

import models.*;
import java.io.*;
import java.util.Vector;

/**
 * Управляет чтением и записью коллекции объектов {@link HumanBeing} в CSV-файл.
 * Реализует интерфейс {@link FileManager}.
 */
public class DumpManager implements FileManager {
    private final String fileName;

    /**
     * Создаёт экземпляр DumpManager, используя путь к файлу из переменной окружения COLLECTION_FILE.
     *
     * @throws IllegalStateException если переменная окружения COLLECTION_FILE не установлена
     */
    public DumpManager() {
        this.fileName = System.getenv("COLLECTION_FILE");
        if (fileName == null || fileName.isEmpty()) {
            throw new IllegalStateException("Переменная окружения COLLECTION_FILE не установлена");
        }
        System.out.println("Используемый файл: " + fileName);
    }

    /**
     * Считывает коллекцию объектов {@link HumanBeing} из настроенного CSV-файла.
     *
     * @return {@link Vector}, содержащий загруженные объекты {@link HumanBeing}
     * @throws IOException если произошла ошибка ввода-вывода при чтении файла
     */
    @Override
    public Vector<HumanBeing> readCollection() throws IOException {
        Vector<HumanBeing> collection = new Vector<>();
        File file = new File(fileName);
        if (!file.exists()) {
            System.out.println("Файл не существует: " + fileName);
            return collection;
        }
        if (!file.canRead()) throw new IOException("Нет прав на чтение файла: " + fileName);

        System.out.println("Читаем файл: " + fileName);
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            int lineNumber = 0;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                lineNumber++;
                if (!line.isEmpty()) {
                    System.out.println("Прочитана строка " + lineNumber + ": " + line);
                    try {
                        HumanBeing human = CsvParser.parseHumanBeing(line);
                        if (human != null) {
                            collection.add(human);
                            System.out.println("Добавлен объект: " + human);
                        } else {
                            System.out.println("Строка " + lineNumber + " вернула null");
                        }
                    } catch (Exception e) {
                        System.err.println("Ошибка парсинга строки " + lineNumber + ": " + line + " (" + e.getMessage() + ")");
                    }
                } else {
                    System.out.println("Пропущена пустая строка " + lineNumber);
                }
            }
            if (lineNumber == 0) {
                System.out.println("Файл пустой или не удалось прочитать ни одной строки");
            }
        }
        return collection;
    }

    /**
     * Записывает коллекцию объектов {@link HumanBeing} в настроенный CSV-файл.
     *
     * @param collection коллекция для записи
     * @throws IOException если произошла ошибка ввода-вывода при записи в файл
     */
    @Override
    public void writeCollection(Vector<HumanBeing> collection) throws IOException {
        File file = new File(fileName);
        File parentDir = file.getParentFile();
        if (parentDir != null && !parentDir.exists()) parentDir.mkdirs();
        if (file.exists() && !file.canWrite()) throw new IOException("Нет прав на запись: " + fileName);

        try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
            for (HumanBeing human : collection) {
                String csvLine = CsvParser.humanToCsv(human);
                writer.println(csvLine);
                System.out.println("Записана строка: " + csvLine);
            }
        }
    }
}package managers;

import models.HumanBeing;
import java.util.Vector;

/**
 * интерфейс для работы с файлами
 */
public interface FileManager {
    Vector<HumanBeing> readCollection() throws java.io.IOException;
    void writeCollection(Vector<HumanBeing> collection) throws java.io.IOException;
}
package managers;

import models.HumanBeing;
import java.util.Vector;

/**
 * Генерирует уникальные идентификаторы для объектов {@link HumanBeing} на основе существующих идентификаторов в коллекции.
 */
public class IdGenerator {
    private long nextId;
    private final Vector<HumanBeing> collection;

    /**
     * Создаёт генератор идентификаторов для указанной коллекции.
     * Устанавливает следующий идентификатор как значение, превышающее максимальный существующий.
     *
     * @param collection коллекция объектов {@link HumanBeing}, на основе которой генерируются идентификаторы
     */
    public IdGenerator(Vector<HumanBeing> collection) {
        this.collection = collection;
        if (collection.isEmpty()) {
            nextId = 1;
        } else {
            nextId = collection.stream()
                    .mapToLong(HumanBeing::getId)
                    .max()
                    .getAsLong() + 1;
        }
        System.out.println("Инициализирован IdGenerator с nextId = " + nextId);
    }

    /**
     * Генерирует уникальный идентификатор для нового объекта {@link HumanBeing}.
     * Гарантирует, что идентификатор не совпадает с уже существующими в коллекции.
     *
     * @return уникальный идентификатор
     */
    public long generateId() {
        while (collection.stream().anyMatch(h -> h.getId() == nextId)) {
            nextId++;
        }
        long id = nextId;
        nextId++;
        System.out.println("Сгенерирован новый id: " + id);
        return id;
    }
}package models;

/**
 * Класс автомобиля
 */
public class Car {
    private String name; // Поле может быть null

    /**
     * Конструктор класса Car
     * @param name имя автомобиля
     */
    public Car(String name) {
        this.name = name;
    }

    public String getName() { return name; }

    /**
     * Возвращает строковое представление объекта
     * @return строка с именем автомобиля
     */
    @Override
    public String toString() {
        return String.format("Car{name='%s'}", name == null ? "null" : name);
    }
}package models;

import utility.Validatable;

/**
 * Представляет координаты объекта с полями x и y.
 */
public class Coordinates implements Validatable {
    private float x; // Значение поля должно быть больше -89
    private int y;  // Значение поля должно быть больше -862

    /**
     * Создаёт новый объект Coordinates с указанными значениями x и y.
     * @param x координата x, должна быть больше -89
     * @param y координата y, должна быть больше -862
     */
    public Coordinates(float x, int y) {
        this.x = x;
        this.y = y;
    }

    public float getX() { return x; }
    public int getY() { return y; }

    /**
     * Проверяет валидность координат: x > -89, y > -862.
     * @return true, если координаты валидны, иначе false
     */
    @Override
    public boolean validate() {
        if (x <= -89) {
            System.out.println("Ошибка: x должен быть больше -89. Текущее значение: " + x);
            return false;
        }
        if (y <= -862) {
            System.out.println("Ошибка: y должен быть больше -862. Текущее значение: " + y);
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "Coordinates{x=" + x + ", y=" + y + "}";
    }
}package models;

import java.time.LocalDateTime;

/**
 * Представляет объект "человек" с изменяемым идентификатором и набором неизменяемых характеристик.
 */
public class HumanBeing implements Comparable<HumanBeing> {
    private long id;
    private final HumanBeingData data;

    private record HumanBeingData(
            String name,
            Coordinates coordinates,
            LocalDateTime creationDate,
            boolean realHero,
            Boolean hasToothpick,
            Long impactSpeed,
            WeaponType weaponType,
            Mood mood,
            Car car
    ) {}

    public HumanBeing(long id, String name, Coordinates coordinates, boolean realHero, Boolean hasToothpick,
                      Long impactSpeed, WeaponType weaponType, Mood mood, Car car) {
        this.id = id;
        this.data = new HumanBeingData(name, coordinates, LocalDateTime.now(), realHero, hasToothpick,
                impactSpeed, weaponType, mood, car);
    }

    public void setId(long id) {
        this.id = id;
    }

    public long getId() {
        return id;
    }

    public String getName() {
        return data.name();
    }

    public Coordinates getCoordinates() {
        return data.coordinates();
    }

    public LocalDateTime getCreationDate() {
        return data.creationDate();
    }

    public boolean isRealHero() {
        return data.realHero();
    }

    public Boolean getHasToothpick() {
        return data.hasToothpick();
    }

    public Long getImpactSpeed() {
        return data.impactSpeed();
    }

    public WeaponType getWeaponType() {
        return data.weaponType();
    }

    public Mood getMood() {
        return data.mood();
    }

    public Car getCar() {
        return data.car();
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.id, other.id);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + data.name() + '\'' +
                ", coordinates=" + data.coordinates() +
                ", creationDate=" + data.creationDate() +
                ", realHero=" + data.realHero() +
                ", hasToothpick=" + data.hasToothpick() +
                ", impactSpeed=" + data.impactSpeed() +
                ", weaponType=" + data.weaponType() +
                ", mood=" + data.mood() +
                ", car=" + data.car() +
                '}';
    }
}package models;

/**
 * Перечисление настроений
 */
public enum Mood {
    SADNESS,
    LONGING,
    APATHY,
    CALM,
    RAGE;
}package models;

/**
 * Перечисление типов оружия
 */
public enum WeaponType {
    PISTOL,
    SHOTGUN,
    KNIFE,
    MACHINE_GUN;
}package utility;

/**
 * Интерфейс для взаимодействия с консолью.
 */
public interface Console {
    /**
     * Выводит сообщение в консоль.
     * @param message сообщение для вывода
     */
    void println(String message);

    /**
     * Считывает строку из консоли.
     * @return введённая строка или null при конце ввода
     */
    String readln();
}package utility;

/**
 * Результат выполнения команды
 */
public class ExecutionResponse {
    private final boolean success;
    private final String message;

    /**
     * Конструктор результата выполнения команды
     * @param success флаг успешности выполнения
     * @param message сообщение с результатом
     */
    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    /**
     * Проверяет, успешно ли выполнена команда
     * @return true, если команда выполнена успешно
     */
    public boolean isSuccess() {
        return success;
    }

    /**
     * Возвращает сообщение с результатом выполнения
     * @return сообщение
     */
    public String getMessage() {
        return message;
    }
}package utility;

import models.*;

import java.util.Arrays;

/**
 * Класс для ввода данных и создания объекта {@link HumanBeing}.
 */
public class HumanBeingAsker {
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    /**
     * Запрашивает данные для создания объекта {@link HumanBeing}.
     * @return новый объект HumanBeing с указанным id или новым, если id = 0
     */
    public HumanBeing askHumanBeing(long id) {
        console.println("Введите name:");
        String name = askNonEmptyString("Ошибка: name не может быть пустым. Повторите ввод:");

        Coordinates coordinates = askCoordinates();

        console.println("realHero (true/false):");
        boolean realHero = askBoolean();

        console.println("hasToothpick (true/false):");
        Boolean hasToothpick = askBoolean();

        console.println("impactSpeed (число или пустая строка для null):");
        Long impactSpeed = askLongOrNull();

        console.println("weaponType (PISTOL, SHOTGUN, KNIFE, MACHINE_GUN или пустая строка для null):");
        console.println("Доступные значения: " + Arrays.toString(WeaponType.values()));
        WeaponType weaponType = askEnumOrNull(WeaponType.class);

        console.println("mood (SADNESS, LONGING, APATHY, CALM, RAGE или пустая строка для null):");
        console.println("Доступные значения: " + Arrays.toString(Mood.values()));
        Mood mood = askEnumOrNull(Mood.class);

        console.println("car name (или пустая строка для null):");
        String carName = console.readln();
        while (carName == null) {
            console.println("Для выхода используйте команду exit.");
            console.println("car name (или пустая строка для null):");
            carName = console.readln();
        }
        Car car = new Car(carName.isEmpty() ? null : carName);

        return new HumanBeing(id, name, coordinates, realHero, hasToothpick, impactSpeed, weaponType, mood, car);
    }

    /**
     * Запрашивает данные для создания объекта {@link HumanBeing} без указания id.
     */
    public HumanBeing askHumanBeing() {
        return askHumanBeing(0); // id будет установлен в CollectionManager.add()
    }

    private Coordinates askCoordinates() {
        while (true) {
            console.println("Введите x:");
            Float x = askFloat();
            if (x == null) continue;

            console.println("Введите y:");
            Integer y = askInteger();
            if (y == null) continue;

            Coordinates coordinates = new Coordinates(x, y);
            if (coordinates.validate()) {
                return coordinates;
            }
            console.println("Повторите ввод:");
        }
    }

    private String askNonEmptyString(String errorMessage) {
        String input = console.readln();
        while (input == null || input.isEmpty()) {
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
            } else {
                console.println(errorMessage);
            }
            console.println("Введите значение:");
            input = console.readln();
        }
        return input;
    }

    private boolean askBoolean() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите true или false:");
                continue;
            }
            input = input.toLowerCase();
            if ("true".equals(input)) return true;
            if ("false".equals(input)) return false;
            console.println("Ошибка: введите true или false. Повторите ввод:");
        }
    }

    private Long askLongOrNull() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите число или пустую строку для null:");
                continue;
            }
            if (input.isEmpty()) return null;
            try {
                return Long.parseLong(input);
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите число или пустую строку. Повторите ввод:");
            }
        }
    }

    private <T extends Enum<T>> T askEnumOrNull(Class<T> enumClass) {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите значение или пустую строку для null:");
                console.println("Доступные значения: " + Arrays.toString(enumClass.getEnumConstants()));
                continue;
            }
            if (input.isEmpty()) return null;
            try {
                return Enum.valueOf(enumClass, input.toUpperCase());
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: введите одно из указанных значений или пустую строку. Повторите ввод:");
            }
        }
    }

    private Float askFloat() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите x:");
                return null;
            }
            try {
                return Float.parseFloat(input.replace(",", "."));
            } catch (NumberFormatException e) {
                console.println("Ошибка: x должен быть числом с плавающей точкой. Повторите ввод:");
            }
        }
    }

    private Integer askInteger() {
        while (true) {
            String input = console.readln();
            if (input == null) {
                console.println("Для выхода используйте команду exit.");
                console.println("Введите y:");
                return null;
            }
            try {
                return Integer.parseInt(input);
            } catch (NumberFormatException e) {
                console.println("Ошибка: y должен быть целым числом. Повторите ввод:");
            }
        }
    }
}package utility;

import managers.CommandManager;

/**
 * Класс для запуска интерактивного режима программы, обрабатывающий команды пользователя через {@link CommandManager}.
 * Предоставляет консольный интерфейс для взаимодействия с коллекцией.
 */
public class Runner {
    private final CommandManager commandManager;
    private final Console console;
    private boolean receivedEOF = false;
    private volatile boolean normalExit = false;

    /**
     * Создаёт новый экземпляр {@link Runner} с указанными менеджером команд и консолью.
     * Настраивает обработку прерывания программы (Ctrl+C) для вывода сообщения о несохранённых данных.
     *
     * @param commandManager менеджер команд для обработки пользовательского ввода
     * @param console консоль для вывода сообщений и чтения ввода пользователя
     */
    public Runner(CommandManager commandManager, Console console) {
        this.commandManager = commandManager;
        this.console = console;

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if (!normalExit) {
                console.println("\nПрограмма прервана (Ctrl+C). Данные не сохранены.");
            }
        }));
    }

    /**
     * Запускает интерактивный режим программы, выводя инструкции и ожидая ввода команд от пользователя.
     * Завершает работу при выполнении команды "exit" или при возникновении ошибки.
     */
    public void interactiveMode() {
        console.println("Добро пожаловать в программу управления коллекцией!");
        console.println("инструкции по управлению в терминале:");
        console.println("- Ctrl+D: Сигнал конца ввода. Программа выведет сообщение и продолжит работу.");
        console.println("- Ctrl+C: Немедленно прерывает программу без сохранения данных.");
        console.println("- Ctrl+Z: Приостанавливает программу и переводит её в фон. Для возобновления введите 'fg'.");
        console.println("- Ctrl+S: Приостанавливает вывод в терминал. Нажмите Ctrl+Q для возобновления.");
        console.println("Введите команду (help для списка команд):");

        while (true) {
            String input = console.readln();
            if (input == null) {
                if (!receivedEOF) {
                    console.println("Для выхода из программы используйте команду exit.");
                    receivedEOF = true;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    console.println("Ошибка: " + e.getMessage());
                }
                continue;
            }
            receivedEOF = false;
            try {
                ExecutionResponse response = commandManager.execute(input);
                console.println(response.getMessage());
                if (!response.isSuccess() && input.equals("exit")) {
                    normalExit = true;
                    break;
                }
            } catch (Exception e) {
                console.println("Произошла ошибка: " + e.getMessage());
                console.println("Введите команду (help для списка команд):");
            }
            console.println("Введите команду (help для списка команд):");
        }
    }
}package utility;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * Стандартная реализация консоли для ввода-вывода через System.in и System.out.
 * Поддерживает чтение из файла при выполнении скрипта.
 */
public class StandardConsole implements Console {
    private BufferedReader reader;
    private Scanner scriptScanner;

    public StandardConsole() {
        this.reader = new BufferedReader(new InputStreamReader(System.in));
        this.scriptScanner = null; // По умолчанию читаем с клавиатуры
    }

    /**
     * Устанавливает источник ввода для скрипта.
     * @param scanner сканнер для чтения из файла скрипта
     */
    public void setScriptScanner(Scanner scanner) {
        this.scriptScanner = scanner;
    }

    /**
     * Сбрасывает источник ввода на клавиатуру.
     */
    public void clearScriptScanner() {
        this.scriptScanner = null;
    }

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String readln() {
        try {
            if (scriptScanner != null && scriptScanner.hasNextLine()) {
                String line = scriptScanner.nextLine().trim();
                println("> " + line); // Эхо ввода для отладки
                return line;
            } else {
                String line = reader.readLine();
                return line != null ? line.trim() : null;
            }
        } catch (Exception e) {
            println("Ошибка ввода: " + e.getMessage());
            return null;
        }
    }

    /**
     * Проверяет, выполняется ли сейчас скрипт.
     * @return true, если читаем из скрипта
     */
    public boolean isScriptMode() {
        return scriptScanner != null;
    }
}package utility;

/**
 * интерфейс для классов, поля которых могут быть валидными или нет.
 */
public interface Validatable {
    boolean validate();
}
